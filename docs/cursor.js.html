<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/cursor.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: core/cursor.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/*! cursor.js */

var utils = require('./utils');
var ConditionParser = require('../core/condition_op');
var ProjectionParser = require('../core/projection_op');

module.exports = Cursor;

function Proto() {}

/**
 * This returns the next object at the cursor.
 *
 * @method Cursor.prototype.nextObject
 * @param {Function} callback - function(err, item) {}
 * @returns {Cursor} instance itself for method chaining
 * @example
 * var cursor = collection.find();
 * cursor.nextObject(function(err, item){
 *   console.log(item);
 * });
 */

Proto.prototype.nextObject = function(callback) {
  if (!this.source) throw new Error('no source');
  this.source.nextObject(callback);
};

/**
 * This resets the cursor position to the original state.
 *
 * @method Cursor.prototype.rewind
 * @returns {Cursor} instance itself for method chaining
 * @example
 * var cursor = collection.find();
 * cursor.nextObject(function(err, item){
 *   console.log(item); // first item
 *   cursor.rewind();
 *   cursor.nextObject(function(err, item){
 *     console.log(item); // first item again
 *   });
 * });
 */

Proto.prototype.rewind = function() {
  if (!this.source) throw new Error('no source');
  if (this.source.rewind) this.source.rewind();
  delete this.nextObject;
  return this;
};

/**
 * This is a Cursor instance constructor. find() and other some methods use this internally.
 *
 * @class Cursor
 * @param {KagoDB} collection - source collection
 * @param {Object|Function} [condition] - query parameters or function
 * @param {Object|Function} [projection] - mapping parameters or function
 */

function Cursor(collection, condition, projection) {
  this.collection = collection;
  this.source = new Source(this.collection);
  this._source = this.source;
  if (condition) {
    condition = ConditionParser.parser(condition);
    if (condition) {
      this.source = new Condition(this.source, condition);
    }
  }
  if (projection) {
    projection = ProjectionParser.parser(projection);
    if (projection) {
      this.source = new Projection(this.source, projection);
    }
  }
}

utils.inherits(Cursor, Proto);

/**
 * This invokes a callback function with an index for all items of the collection whether a condition is given or not.
 *
 * @private
 * @param {Function} callback - function(err, list) {}
 * @returns {Cursor} instance itself for method chaining
 */

Cursor.prototype.index = function(callback) {
  var self = this;
  callback = callback || NOP;
  if (self._index) {
    var list = [].concat(self._index); // clone
    callback(null, list);
  } else {
    self.collection.index(function(err, list) {
      if (err) {
        callback(err);
      } else {
        self._index = list;
        list = [].concat(self._index); // clone
        callback(null, list);
      }
    });
  }
  return this;
};

/**
 * This invokes a callback function with a list of items found.
 *
 * @param {Function} callback - function(err, list) {}
 * @returns {Cursor} instance itself for method chaining
 * @example
 * collection.find().toArray(function(err, list) {
 *   if (err) {
 *     console.error(err);
 *   } else {
 *     list.forEach(function(item) {
 *       console.log(item);
 *     });
 *   }
 * });
 */

Cursor.prototype.toArray = function(callback) {
  var self = this;
  callback = callback || NOP;

  if (self._toArray) {
    var list = [].concat(self._toArray); // clone
    callback(null, list);
  } else {
    toArray(this.source, function(err, list) {
      if (err) {
        callback(err);
      } else {
        self._toArray = list;
        list = [].concat(self._toArray); // clone
        callback(null, list);
      }
    });
  }
  return this;
};

/**
 * This invokes a callback function with each items found.
 *
 * @param {Function} callback - function(err, item) {}
 * @returns {Cursor} instance itself for method chaining
 * @example
 * collection.find().each(function(err, item) {
 *   if (err) {
 *     console.error(err);
 *   } else if (!item) {
 *     // EOF
 *   } else {
 *     console.error(item);
 *   }
 * });
 */

Cursor.prototype.each = function(callback) {
  var self = this;
  callback = callback || NOP;

  this.nextObject(iterator);

  function iterator(err, item) {
    callback(err, item);
    if (!err && item) self.nextObject(iterator);
  }
};

/**
 * This invokes a callback function with the number of items found
 *
 * @param {Function} callback - function(err, count) {}
 * @returns {Cursor} instance itself for method chaining
 * @example
 * collection.find().count(function(err, count) {
 *   console.log(count);
 * });
 */

Cursor.prototype.count = function(callback) {
  callback = callback || NOP;
  var getlist = (this.source === this._source) ? this.index : this.toArray;
  getlist.call(this, function(err, list) {
    if (err) {
      callback(err);
    } else {
      callback(null, list.length);
    }
  });
  return this;
};

/**
 * This specifies a sort parameters
 *
 * @param {Function|Object} order - sort function or parameters
 * @returns {Cursor} instance itself for method chaining
 * @example
 * collection.find().sort(function(a, b){
 *   return a.price - b.price || b.stock - a.stock;
 * }).toArray();
 *
 * var sort = {price: 1, stock: -1});
 * collection.find().sort(sort).toArray(); // same order
 */

Cursor.prototype.sort = function(order) {
  this.source = new Sort(this.source, order);
  return this;
};

/**
 * This specifies a offset parameters
 *
 * @param {Number} offset - offset parameter
 * @returns {Cursor} instance itself for method chaining
 * @example
 * collection.find().offset(100).toArray();
 */

Cursor.prototype.offset = function(offset) {
  this.source = new Offset(this.source, offset);
  return this;
};

/**
 * This specifies a limit parameters
 *
 * @param {Number} limit - limit parameter
 * @returns {Cursor} instance itself for method chaining
 * @example
 * collection.find().limit(100).toArray();
 */

Cursor.prototype.limit = function(limit) {
  this.source = new Limit(this.source, limit);
  return this;
};

function Source(collection) {
  this.collection = collection;
}

utils.inherits(Source, Proto);

Source.prototype.nextObject = function(callback) {
  var self = this;
  callback = callback || NOP;

  // read all keys at first
  this.collection.index(function(err, list) {
    if (err) return callback(err);
    self.list = list || [];
    self.nextObject = self._nextObject;
    self.nextObject(callback);
  });

  return this;
};

Source.prototype._nextObject = function(callback) {
  if (!this.list.length) return callback(); // EOF
  var id = this.list.shift();
  this.collection.read(id, callback);
};

Source.prototype.rewind = function(callback) {
  delete this.nextObject;
};

function Condition(source, condition) {
  this.source = source;
  this.condition = condition;
}

utils.inherits(Condition, Proto);

Condition.prototype.nextObject = function(callback) {
  var self = this;
  var source = this.source;
  var condition = this.condition;
  if ('function' != typeof condition) {
    var err = new Error('invalid condition: ' + condition);
    callback(err);
    return;
  }

  source.nextObject(next);

  function next(err, item) {
    if (err) {
      callback(err);
    } else if (!item) {
      self.nextObject = through;
      callback(); // EOF
    } else if (condition(item)) {
      callback(null, item); // OK
    } else {
      source.nextObject(next); // NG
    }
  }
};

function Sort(source, order) {
  var sorter;
  if ('object' == typeof order) {
    var index = Object.keys(order);
    var keylen = index.length;
    this.sorter = function(a, b) {
      for (var i = 0; i &lt; keylen; i++) {
        var key = index[i];
        if (a[key] &lt; b[key]) {
          return -order[key];
        } else if (a[key] > b[key]) {
          return order[key];
        }
      }
    };
  } else {
    this.sorter = order;
  }
  this.source = source;
}

utils.inherits(Sort, Proto);

Sort.prototype.nextObject = function(callback) {
  var self = this;
  callback = callback || NOP;

  toArray(this.source, function(err, list) {
    if (err) return callback(err);
    list = list || [];
    self.list = list.sort(self.sorter);
    self.nextObject = self._nextObject; // replace
    self.nextObject(callback);
  });
};

Sort.prototype._nextObject = function(callback) {
  callback = callback || NOP;
  var item = this.list.shift();
  callback(null, item);
};

function Offset(source, offset) {
  this.source = source;
  this.offset = offset;
}

utils.inherits(Offset, Proto);

Offset.prototype.nextObject = function(callback) {
  var self = this;
  var rest = this.offset;
  var source = this.source;
  callback = callback || NOP;

  if (rest > 0) {
    source.nextObject(iterator);
  } else {
    ready();
  }

  function iterator(err, item) {
    if (err) {
      callback(err); // error on read
    } else if (!item) {
      self.nextObject = through; // EOF
      callback();
    } else if (--rest > 0) {
      source.nextObject(iterator); // skip
    } else {
      ready();
    }
  }

  function ready() {
    self.nextObject = Proto.prototype.nextObject; // replace
    self.nextObject(callback);
  }
};

function Limit(source, limit) {
  this.source = source;
  this.limit = limit;
  this.rest = this.limit;
}

utils.inherits(Limit, Proto);

Limit.prototype.nextObject = function(callback) {
  var source = this.source;
  callback = callback || NOP;

  if (this.rest-- > 0) {
    source.nextObject(callback);
  } else {
    this.nextObject = through;
    callback();
  }
};

Limit.prototype.rewind = function() {
  this.rest = this.limit;
  Proto.prototype.rewind.call(this);
};

function Projection(source, projection) {
  this.source = source;
  this.projection = projection;
}

utils.inherits(Projection, Proto);

Projection.prototype.nextObject = function(callback) {
  var self = this;
  var projection = this.projection;

  if ('function' != typeof projection) {
    var err = new Error('invalid projection: ' + projection);
    callback(err);
    return;
  }

  this.source.nextObject(function(err, item) {
    if (err) {
      callback(err);
    } else if (!item) {
      self.nextObject = through; // EOF
      callback();
    } else {
      item = projection(item);
      callback(null, item);
    }
  });
};

function toArray(source, callback) {
  var buf = [];
  callback = callback || NOP;
  source.nextObject(iterator);

  function iterator(err, item) {
    // error on read
    if (err) {
      callback(err);
      return;
    }

    // last item
    if (!item) {
      callback(null, buf);
      return;
    }

    buf.push(item);

    source.nextObject(iterator);
  }
}

function through(callback) {
  if (callback) callback();
}

function NOP() {}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-condition_op.html">condition_op</a></li><li><a href="module-projection_op.html">projection_op</a></li><li><a href="module-system.html">system</a></li><li><a href="module-update_op.html">update_op</a></li><li><a href="module-utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="Cursor.html">Cursor</a></li><li><a href="KagoDB.html">KagoDB</a></li><li><a href="ObjectID.html">ObjectID</a></li></ul><h3>Mixins</h3><ul><li><a href="deny.html">deny</a></li><li><a href="dynamic_mixin.html">dynamic_mixin</a></li><li><a href="events.html">events</a></li><li><a href="find.html">find</a></li><li><a href="http_jquery.html">http_jquery</a></li><li><a href="http_request.html">http_request</a></li><li><a href="http_superagent.html">http_superagent</a></li><li><a href="insert.html">insert</a></li><li><a href="intercept_mixin.html">intercept_mixin</a></li><li><a href="json.html">json</a></li><li><a href="local_storage.html">local_storage</a></li><li><a href="memory.html">memory</a></li><li><a href="model.html">model</a></li><li><a href="noop.html">noop</a></li><li><a href="pkey.html">pkey</a></li><li><a href="remove.html">remove</a></li><li><a href="request.html">request</a></li><li><a href="request_jquery.html">request_jquery</a></li><li><a href="request_superagent.html">request_superagent</a></li><li><a href="storage.html">storage</a></li><li><a href="update.html">update</a></li><li><a href="webapi.html">webapi</a></li><li><a href="yaml.html">yaml</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Thu Jun 13 2013 22:04:40 GMT+0900 (JST)
</footer>

<script> prettyPrint(); </script>
</body>
</html>
